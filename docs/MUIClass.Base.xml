<?xml version="1.0" encoding="ISO-8859-1"?>
<fpdoc-descriptions>
<package name="MUIClass">

<!--
  ====================================================================
    MUIClass.Base
  ====================================================================
-->

<module name="MUIClass.Base">
<short>Base Objects and Application</short>
<descr>
  <p>
  Unit contains the very basic classes, most of them are not meant to
  create by the user but only used as base classes for the more
  complex objects.</p>
  <p>The only user object in this unit is the <link id="TMUITimer">Timer</link> object.</p>
  <p>
    <link id="MUIApp">MUIApp</link> is the global MUI application object for
    all actions. Therefore the user do not need to create (or destroy) and application
    object. (it will be created in the initialization and destroyed in the finalization part
    of this unit).
  </p>
  <p>Check <link id="MUIApp">MUIApp</link> for a simple Hello world example source.</p>
</descr>

<!-- uses unit Visibility: default -->
<element name="System">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="Classes">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="SysUtils">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="fgl">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="Math">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="Exec">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="Utility">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="AmigaDOS">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="Intuition">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="icon">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="Commodities">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="mui">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="muihelper">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- uses unit Visibility: default -->
<element name="tagsparamshelper">
<short></short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: default -->
<element name="ComplainIOnly">
<short>Create debugoutput about an illegal field access</short>
<descr>
  Program tried to change a field which is only setable before the actual
  MUI object is created aber the MUI object is created.
  The value will be ignored and a message is sent to debugout.
</descr>
</element>

<!-- class Visibility: default -->
<element name="THookList">
<short>A List of Hooks, wich will be automatically destroyed on exit</short>
<descr>
<p>
  Often you need to instance Hooks, and keep the Hook pointer, but you don't actually need
  the Hook itself (just the memory should be remembered).
  The easiest way is to use this class for bookkeeping opened Hooks.</p>
<p><b>Example:</b></p>
<code>
var
  Hook: PHook;
begin
  Hook := HookList.GetNewHook;        // get a new Hook Pointer
  MH_SetHook(Hook^, PressFunc, Self); // set the Hook fields
  //Connect the Hook to the Pressed property of Area
  DoMethod(ButtonObj, [MUIM_Notify, MUIA_Pressed, AsTag(False), AsTag(AObj), 2, MUIM_CallHook, AsTag(Hook)]);
  // you do not need to keep the Hook anymore, it will be destroyed on HookList.destroy
end;
</code>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="THookList.Create">
<short>Create a new Hooklist</short>
</element>

<!-- destructor Visibility: public -->
<element name="THookList.Destroy">
<short>Destroy List, all Hooks are freed before</short>
</element>

<!-- function Visibility: public -->
<element name="THookList.GetNewHook">
<short>Get a new Hook, and add it to List</short>
</element>

<!-- function result Visibility: public -->
<element name="THookList.GetNewHook.Result">
<short>Hook to use for MUI events</short>
</element>

<!-- procedure Visibility: public -->
<element name="THookList.RemoveHook">
<short>Hook is not needed anymore, remove it from list, Hook is freed</short>
</element>

<!-- argument Visibility: default -->
<element name="THookList.RemoveHook.AHook">
<short>Hook to be removed and free, do not use the Poiner afterwards</short>
</element>

<!-- class Visibility: default -->
<element name="TMUIRootClass">
<short>Base class for all MUI Class</short>
<descr>
  it does not make sense to instance itself
  (it's even not possible)
</descr>
<seealso>
</seealso>
</element>

<!-- variable Visibility: protected -->
<element name="TMUIRootClass.HookList">
<short>List of Hooks used in this class</short>
</element>

<!-- variable Visibility: protected -->
<element name="TMUIRootClass.FFirstOpen">
<short>First visible on a open window</short>
<descr>
  Will be called by the open routine of the Window.
</descr>
</element>

<!-- variable Visibility: protected -->
<element name="TMUIRootClass.FMUIObj">
<short>MUI Object, nil when MUI object sill not created or already destroyed</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIRootClass.GetCreateTags">
<short>Get a TagList to create the MUI Object</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.GetCreateTags.ATagList">
<short>TagList to fill</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIRootClass.DoFirstOpen">
<short>Window with this object opens first Time</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIRootClass.SetValue">
<short>Set a MUI object Value via Tag</short>
<descr>
  <p>
   Set a Field Value via Tag and Value as in a Taglist to the internal MUI Object.
   If internal MUI object not created will be ignored.
   Would be a good idea to test <link id="TMUIRootClass.HasObj">HasObj</link> before to make sure
   the object exists.</p>
   <p><b>Example:</b></p>
<code>
if HasObj then // Check if the MUI object is asigned
  SetValue(MUIA_Disabled, AsTag(FDisabled)); // Do the actual setting
</code>
</descr>
<seealso>
  <link id="TMUIRootClass.MUIObj">MUIObj</link>
  <link id="TMUIRootClass.HasObj">HasObj</link>
  <link id="TMUIRootClass.GetIntValue">GetIntValue</link>
  <link id="TMUIRootClass.GetBoolValue">GetBoolValue</link>
  <link id="TMUIRootClass.GetPointerValue">GetPointerValue</link>
  <link id="TMUIRootClass.GetStringValue">GetStringValue</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.SetValue.Tag">
<short>MUI Tag to set</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.SetValue.Value">
<short>Value to set</short>
</element>

<!-- function Visibility: protected -->
<element name="TMUIRootClass.GetIntValue">
<short>Get a MUI Value via Tag as Integer</short>
<descr>
<p>
   Get a Field Value via Tag as Integer Value from the internal MUI Object.
   If internal MUI object not created it will return 0.
   Would be a good idea to test <link id="TMUIRootClass.HasObj">HasObj</link> before to make sure
   the object exists.</p>
<p><b>Example:</b></p>
<code>
Page := -1; // Illegal Value as Default, when object is not created
if HasObj then
  Page := GetIntValue(MUIA_Group_ActivePage);
</code>
</descr>
<seealso>
  <link id="TMUIRootClass.MUIObj">MUIObj</link>
  <link id="TMUIRootClass.HasObj">HasObj</link>
  <link id="TMUIRootClass.SetValue">SetValue</link>
  <link id="TMUIRootClass.GetIntValue">GetIntValue</link>
  <link id="TMUIRootClass.GetBoolValue">GetBoolValue</link>
  <link id="TMUIRootClass.GetPointerValue">GetPointerValue</link>
  <link id="TMUIRootClass.GetStringValue">GetStringValue</link>
</seealso>
</element>

<!-- function result Visibility: protected -->
<element name="TMUIRootClass.GetIntValue.Result">
<short>Field Value as Integer or 0 if MUI Object is not created</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.GetIntValue.Tag">
<short>Field to get as Tag</short>
</element>

<!-- function Visibility: protected -->
<element name="TMUIRootClass.GetBoolValue">
<short>Get a MUI Value via Tag as Boolean</short>
<descr>
<p>
  Get a Field Value via Tag as Boolean Value from the internal MUI Object.
  If internal MUI object not created it will return False.
  Would be a good idea to test <link id="TMUIRootClass.HasObj">HasObj</link> before to make sure
   the object exists.</p>
<p><b>Example:</b></p>
<code>
IsEnabled := False; // No enabled, when no object is there
if HasObj then
  IsEnabled := not GetBoolValue(MUIA_Disabled); // Get the field contents
</code>
</descr>
<seealso>
  <link id="TMUIRootClass.MUIObj">MUIObj</link>
  <link id="TMUIRootClass.HasObj">HasObj</link>
  <link id="TMUIRootClass.SetValue">SetValue</link>
  <link id="TMUIRootClass.GetIntValue">GetIntValue</link>
  <link id="TMUIRootClass.GetBoolValue">GetBoolValue</link>
  <link id="TMUIRootClass.GetPointerValue">GetPointerValue</link>
  <link id="TMUIRootClass.GetStringValue">GetStringValue</link>
</seealso>
</element>

<!-- function result Visibility: protected -->
<element name="TMUIRootClass.GetBoolValue.Result">
<short>Contents of the Field defined by Tag, or False when MUI Object is not created.</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.GetBoolValue.Tag">
<short>Field to get as Tag</short>
</element>

<!-- function Visibility: protected -->
<element name="TMUIRootClass.GetPointerValue">
<short>Get a MUI Value via Tag as Pointer</short>
<descr>
<p>
  Get a Field Value via Tag as Pointer Value from the internal MUI Object.
  If internal MUI object not created it will return nil.
  Would be a good idea to test <link id="TMUIRootClass.HasObj">HasObj</link> before to make sure
   the object exists.</p>
<p><b>Example:</b></p>
<code>
Window := nil; // when no object is there
if HasObj then
  Window := GetPointerValue(MUIA_Window); // Get intuition window structure
</code>
</descr>
<seealso>
  <link id="TMUIRootClass.MUIObj">MUIObj</link>
  <link id="TMUIRootClass.HasObj">HasObj</link>
  <link id="TMUIRootClass.SetValue">SetValue</link>
  <link id="TMUIRootClass.GetIntValue">GetIntValue</link>
  <link id="TMUIRootClass.GetBoolValue">GetBoolValue</link>
  <link id="TMUIRootClass.GetPointerValue">GetPointerValue</link>
  <link id="TMUIRootClass.GetStringValue">GetStringValue</link>
</seealso>
</element>

<!-- function result Visibility: protected -->
<element name="TMUIRootClass.GetPointerValue.Result">
<short>Contents of the Field defined by Tag or nil if Object is not created</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.GetPointerValue.Tag">
<short>Field to get as Tag</short>
</element>

<!-- function Visibility: protected -->
<element name="TMUIRootClass.GetStringValue">
<short>Get a MUI Value via Tag as String</short>
<descr>
<p>
  Get a Field Value via Tag as string Value from the internal MUI Object.
  If internal MUI object not created it will return a empty string ('').
  Would be a good idea to test <link id="TMUIRootClass.HasObj">HasObj</link> before to make sure
   the object exists.</p>
<p><b>Example:</b></p>
<code>
Text := ''; // when no object is there
if HasObj then
  Text := GetStringValue(MUIA_String_Contents); // Get intuition window structure
</code>
</descr>
<seealso>
  <link id="TMUIRootClass.MUIObj">MUIObj</link>
  <link id="TMUIRootClass.HasObj">HasObj</link>
  <link id="TMUIRootClass.SetValue">SetValue</link>
  <link id="TMUIRootClass.GetIntValue">GetIntValue</link>
  <link id="TMUIRootClass.GetBoolValue">GetBoolValue</link>
  <link id="TMUIRootClass.GetPointerValue">GetPointerValue</link>
  <link id="TMUIRootClass.GetStringValue">GetStringValue</link>
</seealso>
</element>

<!-- function result Visibility: protected -->
<element name="TMUIRootClass.GetStringValue.Result">
<short>Contents of the Field defined by Tag or an empty string if Object is not created.</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.GetStringValue.Tag">
<short>Field to get as Tag</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIRootClass.ConnectHookObject">
<short>Connect a Event (via Hook) to a changing Field Value with given object</short>
<descr>
<p>
  Set the Hook to the Hook function and install a Notify Event for the
  given Field and Value. The Hook Data points to this Pascal object.
  in principle it does something like:</p>
  <code>
  MH_SetHook(Hook, HookFunc, Self);
  DoMethod(AObj, [MUI_Notify, MUIField, TriggerValue, MUIV_Notify_Self, 2, MUIM_CallHook, NativeUInt(Hook)]);
  </code>
  <p>
  Better use <link id="TMUIRootClass.ConnectHook">ConnectHook</link> which uses the internal object, it should be very seldom to use this explicit function</p>
</descr>
<seealso>
  <link id="TMUIRootClass.ConnectHook">ConnectHook</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.ConnectHookObject.AObj">
<short>Object to set the Event</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.ConnectHookObject.MUIField">
<short>Field to trigger</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.ConnectHookObject.TriggerValue">
<short>Value when the Event should be fired or MUIV_EveryTime trigger for every change</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.ConnectHookObject.HookFunc">
<short>Event function to call when event is triggered</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIRootClass.ConnectHook">
<short>Connect a Event (via Hook) to a changing Field Value with internal object</short>
<descr>
<p>
  Set the Hook to the Hook function and install a Notify Event for the
  given Field and Value. The Hook Data points to this Pascal object.
  in principle it does something like:</p>
  <code>
  MH_SetHook(Hook, HookFunc, Self);
  DoMethod(MUIObj, [MUI_Notify, MUIField, TriggerValue, MUIV_Notify_Self, 2, MUIM_CallHook, NativeUInt(Hook)]);
  </code>
<p>
  Best place to use that is inside <link id="TMUINotify.AfterCreateObject">AfterCreateObject</link>.</p>
<p><b>Example:</b></p>
<code>
function PressFunc(Hook: PHook; Obj: PObject_; Msg: Pointer): PtrInt;
var
  PasObj: TMUIArea;
begin
  Result := 0;
  PasObj := TMUIArea(Hook^.h_Data);
  writeln('Got a click event of Object ', PasObj.Classname);
end;

// in AfterCreateObject() connect the Event
ConnectHook(MUIA_Pressed, MUI_FALSE, @PressFunc);</code>
</descr>
<seealso>
  <link id="TMUINotify.AfterCreateObject">AfterCreateObject</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.ConnectHook.MUIField">
<short>Field to Trigger</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.ConnectHook.TriggerValue">
<short>Value when the Event should be fired or MUIV_EveryTime trigger for every change</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIRootClass.ConnectHook.HookFunc">
<short>Event function to call when event is triggered</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIRootClass.ClearObject">
<short>RootClass has no object to destroy</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIRootClass.BeforeCloseWindow">
<short>Called before the Window closes, to clean some stuff</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIRootClass.Create">
<short>Create a Root class, there is no reason to instance a root class it self</short>
</element>

<!-- destructor Visibility: public -->
<element name="TMUIRootClass.Destroy">
<short>Destroy root class, no need to do that, because should not be crated in the first place</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIRootClass.CreateObject">
<short>Creates the MUI item</short>
<descr>
<p><b>Root class object can not be created</b></p>
<p>Derived classes <b>must</b> override this function but <b>not</b> call inherited
(also when overriding classes which have this function implemented)</p>
<p>A typical CreateObject() implementation looks like this:</p>
<code>
procedure TMUIMyNewClass.CreateObject;
var
  TagList: TATagList;  // Taglist for the creation tags
begin
  if not Assigned(FMUIObj) then  // if already created, just skip,
  begin
    BeforeCreateObject;     // you have to implement if your class has childs which are not in childlist and needs to be created
    GetCreateTags(TagList); // implement to add Tags to the creation TagList (already some inside from inherited classes)
    FMUIObj := MUI_NewObjectA(MUIC_XXX, TagList.GetTagPointer); // here also possible NewObjectA() for own subclasses
    AfterCreateObject;      // implement if you need to setup events or other values to set after the object is created
  end;
end;
</code>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIRootClass.DestroyObject">
<short>Root class object can not be destroyed</short>
</element>

<!-- property Visibility: public -->
<element name="TMUIRootClass.MUIObj">
<short>The MUI Object if created</short>
</element>

<!-- property Visibility: public -->
<element name="TMUIRootClass.HasObj">
<short>Is the MUI Object created and can be used</short>
</element>

<!-- specialized class type Visibility: default -->
<element name="TChildList">
<short>List of Children</short>
</element>

<!-- class Visibility: default -->
<element name="TMUINotify">
<short>Notify class is superclass of all other MUI classes.</short>
<descr>
It's main purpose is to handle MUI's notification
mechanism, but it also contains some other methods
and attributes useful for every object.
</descr>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUINotify.AfterCreateObject">
<short>Connect Events to the object</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUINotify.BeforeCreateObject">
<short>Create Children or other connected MUI Object before creating this MUI Object</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUINotify.DoFirstOpen">
<short>Called when Window with this object opens the first time</short>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUINotify.BeforeCloseWindow">
<short>Called before the Window with this Object gets closed (and/or destroyed)</short>
</element>

<!-- property Visibility: protected -->
<element name="TMUINotify.Childs">
<short>List of Children, be careful not all object can have children</short>
</element>

<!-- property Visibility: protected -->
<element name="TMUINotify.FExchangeMode">
<short>True if the Group/Window is in Exchange mode, allows adding of items in runtime</short>
<seealso>
  <link id="TMUINotify.InitChange">InitChange()</link>
  <link id="TMUINotify.ExitChange">ExitChange()</link>
</seealso>
</element>

<!-- property Visibility: protected -->
<element name="TMUINotify.InitChange">
<short>Put Group or Window into exchange mode, allows to add/remove items in runtime</short>
<seealso>
  <link id="TMUINotify.ExitChange">ExitChange()</link>
</seealso>
</element>

<!-- property Visibility: protected -->
<element name="TMUINotify.ExitChange">
<short>Put Group or Window back to normal mode, after adding/removing items in runtime</short>
<seealso>
  <link id="TMUINotify.InitChange">InitChange()</link>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TMUINotify.Create">
<short>it make no sense to instance Notify</short>
</element>

<!-- destructor Visibility: public -->
<element name="TMUINotify.Destroy">
<short>It make no sense to instance Notify, or destroy it</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUINotify.DestroyObject">
<short>It will destroy this class, and clear all children objects</short>
<seealso>
  <link id="TMUINotify.ClearObject">DestroyObject</link>
</seealso>

</element>

<!-- procedure Visibility: public -->
<element name="TMUINotify.ClearObject">
<short>Clear the MUI Object and all it's Childs</short>
<descr>
  When a Parent MUI object is destroyed, it will destroy all it's childs automatically.
  Usually only <link id="TMUINotify.DestroyObject">DestroyObject</link> is called for the most top most object,
  (mostly <link id="TMUIApplication">Application</link>, which will do it itself, when the main window is closed) which will destroy
  all other MUI objects as well. And this function will clean the MUI Object pointers in all Child Pascal Objects to reflect this.
</descr>
<seealso>
  <link id="TMUIRootClass.DestroyObject">DestroyObject</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TMUINotify.AddChild">
<short>Add an object as child to this Class, will be called by setting the Parent on this class</short>
<descr>
  There is no reason to directly call this function, assign this object as a Parent to an other Class, will do it already
</descr>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUINotify.AddChild.AChild">
<short>Child to add</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUINotify.RemoveChild">
<short>Removes a child from this class, will be called when Parent of the child class is changed</short>
<descr>
  There is no reason to directly call this function, assign another object (or nil) as a Parent to an other Class, will do it already
</descr>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUINotify.RemoveChild.AChild">
<short>Object to remove</short>
</element>

<!-- class function Visibility: public -->
<element name="TMUINotify.GetPasObject">
<short>Get the Pascal object which belongs to the MUI Object</short>
<descr>
  The Pascal Object is saved in the UserData of every MUI Object.
  Could be used in Events.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TMUINotify.GetPasObject.Result">
<short>Pascal object of the MUI Object, or nil if no Pascal object is assigned</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUINotify.GetPasObject.AMUIObj">
<short>MUI Object to get the Pascal object from</short>
</element>

<element name="TMUINotify.GetCreateTags">
<short>Fill Taglist with informations for creation</short>
</element>

<element name="TMUINotify.GetCreateTags.ATagList">
<short>TagList to Fill</short>
</element>

<element name="TMUINotify.HelpNode">
<short>Define a node in a help file specified with <link id="TMUIApplication.HelpFile">MUIApp.HelpFile</link></short>
</element>

<element name="TMUINotify.HelpLine">
<short>Define a line in a help file specified with <link id="TMUIApplication.HelpFile">MUIApp.HelpFile</link></short>
</element>


<!-- specialized class type Visibility: default -->
<element name="TTimerList">
<short>List of Timers</short>
<descr>List of Timer Objects, Timer can be just instanced and will be automatically connected to the global Application.
</descr>
</element>

<!-- class Visibility: default -->
<element name="TMUIApplication">
<short>The Application object, will be created as <link id="MUIApp">MUIApp</link> at start of the program.</short>
<descr>
  At the moment it's not planed to have multiple Application objects, thus it could make sense to emulate Modal windows.
  Complain if you want to have that changed. The main application object will be automatically created at start of the
  program and destroyed at the end.
  See <link id="MUIApp">MUIApp</link> for an example.
</descr>
<seealso>
  <link id="MUIApp">MUIApp</link>
</seealso>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIApplication.Create">
<short>Create the Application object</short>
<descr>
  At the moment it's not planed to have multiple Application objects, thus it could make sense to emulate Modal windows.
  Complain if you want to have that changed. The main application object will be automatically created at start of the
  program and destroyed at the end.
</descr>
<seealso>
  <link id="MUIApp">MUIApp</link>
</seealso>
</element>

<!-- destructor Visibility: public -->
<element name="TMUIApplication.Destroy">
<short>Destroy the application object</short>
<descr>
  At the moment it's not planed to have multiple Application objects, thus it could make sense to emulate Modal windows.
  Complain if you want to have that changed. The main application object will be automatically created at start of the
  program and destroyed at the end.
</descr>
<seealso>
</seealso>
<seealso>
  <link id="MUIApp">MUIApp</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.GetCreateTags">
<short>Fill the Taglist with the informations to create the Application Object</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIApplication.GetCreateTags.ATagList">
<short>TagLsit to Fill</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.CreateObject">
<short>Create the MUI application item</short>
<descr>
  This will be called by the <link id="TMUIApplication.Run">Run()</link> method. There is no reason to call that directly.
</descr>
<seealso>
  <link id="TMUIApplication.Run">Run()</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.AfterCreateObject">
<short>Connect events after MUI application object is created</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.DestroyObject">
<short>Destroy the MUI application item</short>
<descr>
  This will be called by the <link id="TMUIApplication.Run">Run()</link> method. There is no reason to call that directly.
</descr>
<seealso>
  <link id="TMUIApplication.Run">Run()</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.Run">
<short>Run the application.</short>
<descr>
  <p>
  If you set everything in your program, configured every Window and item you can start the MUI application
  with this Method. It will create all the MUI object open the Main Window and run the event loop.</p>
  <p>
  If the main window close it will destroy all MUI objects.</p>
  <p><b>Note</b>: Make sure you set all fields which are marked with <b>[i]</b> (which means only set on Init) are set
  before this call.</p>
  <p>Run() will not return before the Application is finished.</p>
  <p>See <link id="MUIApp">MUIApp</link> for an example</p>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.Terminate">
<short>Terminate the currently running application</short>
<descr>
  <p>
  It will not terminate immedately, it will terminate when it reaches the event loop again.
  Only effective after <link id="TMUIApplication.Run">Run()</link> was started.</p>
<p><b>Example:</b></p>
<code>
// Event connected to a Button
procedure TMyWindow.CloseButtonEvent(Sender: TObject);
begin
  MUIApp.Terminate; // kill the application
end;
</code>
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TMUIApplication.Terminated">
<short>True if the application got terminated</short>
<descr>
  <p>
  True if the Application got terminated but did not returned to the Eventloop
  to actually to it.
  </p>
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TMUIApplication.MainWindow">
<short>Link to the Main Window which will terminate the application when closed</short>
</element>

<!-- property Visibility: public -->
<element name="TMUIApplication.Childs">
<short>List of children of this application actually all <link id="TMUIApplication">TMUIApplication</link></short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.AddToDestroy">
<short>Add an object to destroy.</short>
<descr>
  When an object should be destroyed inside it's own eventhandler, it will crash.
  Here it can be added to a list of delayed dstruction list, which will be cleared
  on the next Eventloop cycle.
</descr>
<seealso>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIApplication.AddToDestroy.AObj">
<short>Object to destroy</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.AboutMUI">
<short>Open the About MUI Window</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIApplication.AboutMUI.Window">
<short>The About MUI Window will be centered over this window</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.AddInputHandler">
<short>Adds an Input handler to for your object</short>
<descr>
To be able to react on signals, you must fill out a
PMUI_InputHandlerNode structure (probably located in
your classes instance data) and call
AddInputHandler() with the structure
as parameter. From now on, your class will receive
the specified method whenever one of the given signals
arrives.
</descr>
<seealso>
  <link id="TMUIApplication.RemInputHandler">RemInputHandler()</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIApplication.AddInputHandler.IhNode">
<short>Pointer to an initialized TMUI_InputHandlerNode</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.RemInputHandler">
<short>Remove the Eventhandler for your object</short>
<descr>
</descr>
<seealso>
  <link id="TMUIApplication.AddInputHandler">AddInputHandler()</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIApplication.RemInputHandler.IhNode">
<short>Pointer to an initialized TMUI_InputHandlerNode used for <link id="TMUIApplication.AddInputHandler">AddInputHandler()</link></short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.CheckRefresh">
<short>Check if a MUI Item need a refresh, when blocked by ASL requester.</short>
<descr>
<p>
This method checks all currently open windows if they
need refreshing and refreshes them if necessary.</p>
<p>
You won't need to call this method if you are within
your traditional MUI main loop. However, if you e.g.
spawn some kind of synchronous requester (AslRequest),
MUI cannot react on IDCMP_REFRESHWINDOW messages.</p>
<p>
The result is that the user may see a damaged MUI window
if he moves around a file requester and MUI is configured
for simple refresh.</p>
<p>CheckRefresh() is the solution for this problem. just call this function inside the IntuiMsgHook
of the ASL Requester.</p>
</descr>
<seealso>
  <link id="TMUIApplication.InputBuffered">InputBuffered</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.InputBuffered">
<short>Buffer Input Messages on time consuming operations</short>
<descr>
<p>
Imagine your application does some time consuming
operation, e.g. copying a disk, and you are for
some reasons unable to react on return ids during
this period. One solution would be to simply
put your application to sleep, it will get a
busy pointer and the user knows whats going on.</p>
<p>
However, this will make it impossible for the user
to resize your applications windows or iconify it,
he will have to wait until you are done with your
operation.</p>
<p>
InputBuffered() offers a solution
for this problem. Using this method, you needn't
set to sleep your application. Just call it on a
regular basis and MUI will be able to handle
all actions concerning the GUI. You do not need
to pay attention on return values, they remain
on an internal stack until your next call to
the non buffered input method.
</p>
</descr>
<seealso>
  <link id="TMUIApplication.Sleep">Sleep</link>
</seealso>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.Load">
<short>Load program configuration for items with <link id="MUIClass.Area.TMUIArea.ObjectID">ObjectID</link></short>
<descr>
<p>
  Each gadget with <link id="MUIClass.Area.TMUIArea.ObjectID">ObjectID</link> &lt;&gt;0 will get
  its contents saved during <link id="TMUIApplication.Save">Save()</link> and
  restored during Load(). This makes
  it very easy to design a configuration window
  with "Save", "Use" and "Cancel" buttons to allow
  the user storing the settings. When the application
  starts, you would just have to call Load()
  and the stored settings will be read and installed.
</p>
<p>
  Not all classes are able to import and export their
  contents. Currently, you may define a <link id="MUIClass.Area.TMUIArea.ObjectID">ObjectID</link> for
</p>
  <dl>
    <dt><link id="MUIClass.Gadget.TMUIString">String</link> class</dt><dd><link id="MUIClass.Gadget.TMUIString.Contents">String.Contents</link> is ex/imported</dd>
    <dt><link id="MUIClass.Group.TMUIRadio">Radio</link> class</dt><dd><link id="MUIClass.Group.TMUIRadio.Active">Radio.Active</link> is ex/imported</dd>
    <dt><link id="MUIClass.Group.TMUICycle">Cycle</link> class</dt><dd><link id="MUIClass.Group.TMUICycle.Active">Cycle.Active</link> is ex/imported</dd>
    <dt><link id="MUIClass.List.TMUIList">List</link> class</dt><dd><link id="MUIClass.List.TMUIList.Active">List.Active</link> is ex/imported</dd>
    <dt><link id="MUIClass.Area.TMUIText">Text</link> class</dt><dd><link id="MUIClass.Area.TMUIText.Contents">Text.Contents</link> is ex/imported</dd>
    <dt><link id="MUIClass.Area.TMUIArea">Area</link> class</dt><dd><link id="MUIClass.Area.TMUIArea.Selected">Area.Selected</link> is ex/imported (e.g. CheckMarks)</dd>
    <dt><link id="MUIClass.Menu.TMUIMenuItem">MenuItem</link> class</dt><dd><link id="MUIClass.Menu.TMUIMenuItem.Checked">MenuItem.Checked</link> is ex/imported</dd>
    <dt><link id="MUIClass.Group.TMUIGroup">Group</link> class</dt><dd><link id="MUIClass.Group.TMUIGroup.ActivePage">Group.ActivePage</link> is ex/imported</dd>
  </dl>
</descr>
<seealso>
  <link id="TMUIApplication.Save">Save()</link>
  <link id="MUIClass.Area.TMUIArea.ObjectID">ObjectID</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIApplication.Load.FromEnvarc">
<short>True = load from EnvArc:; False Load from ENV:</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.OpenConfigWindow">
<short>Open application specific configuration window.</short>
<descr>
<p>
  MUI applications can open their own MUI configuration
  window to allow users to adjust the local preferences without
  the need of an external program. Programmers are supposed to
  include a "Settings/MUI..." menu item which simply calls
  OpenConfigWindow(). MUI will then automatically
  show the preferences window without blocking the rest of the
  program.</p>
<p><b>Example:</b></p>
<code>
procedure TMyWindow.ConfigMenu(Sender: TObject);
begin
  MUIApp.OpenConfigWindow();
end;

// somewhere in the Object creation
with TMUIMenuItem.Create do
begin
  Title := 'Settings/MUI...'; // the menu item text
  OnTrigger := @ConfigMenu;   // connect event handler
  Parent := Menu;             // put to the Menu
end;
</code>
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.Save">
<short>Save program configuration for items with <link id="MUIClass.Area.TMUIArea.ObjectID">ObjectID</link>s</short>
<descr>
<p>
  Each gadget with <link id="MUIClass.Area.TMUIArea.ObjectID">ObjectID</link> &lt;&gt;0 will get
  its contents saved during Save() and
  restored during <link id="TMUIApplication.Load">Load()</link>. This makes
  it very easy to design a configuration window
  with "Save", "Use" and "Cancel" buttons to allow
  the user storing the settings. When the application
  starts, you would just have to call Load()
  and the stored settings will be read and installed.
</p>
<p>
  Not all classes are able to import and export their
  contents. Currently, you may define a <link id="MUIClass.Area.TMUIArea.ObjectID">ObjectID</link> for
</p>
  <dl>
    <dt><link id="MUIClass.Gadget.TMUIString">String</link> class</dt><dd><link id="MUIClass.Gadget.TMUIString.Contents">String.Contents</link> is ex/imported</dd>
    <dt><link id="MUIClass.Group.TMUIRadio">Radio</link> class</dt><dd><link id="MUIClass.Group.TMUIRadio.Active">Radio.Active</link> is ex/imported</dd>
    <dt><link id="MUIClass.Group.TMUICycle">Cycle</link> class</dt><dd><link id="MUIClass.Group.TMUICycle.Active">Cycle.Active</link> is ex/imported</dd>
    <dt><link id="MUIClass.List.TMUIList">List</link> class</dt><dd><link id="MUIClass.List.TMUIList.Active">List.Active</link> is ex/imported</dd>
    <dt><link id="MUIClass.Area.TMUIText">Text</link> class</dt><dd><link id="MUIClass.Area.TMUIText.Contents">Text.Contents</link> is ex/imported</dd>
    <dt><link id="MUIClass.Area.TMUIArea">Area</link> class</dt><dd><link id="MUIClass.Area.TMUIArea.Selected">Area.Selected</link> is ex/imported (e.g. CheckMarks)</dd>
    <dt><link id="MUIClass.Menu.TMUIMenuItem">MenuItem</link> class</dt><dd><link id="MUIClass.Menu.TMUIMenuItem.Checked">MenuItem.Checked</link> is ex/imported</dd>
    <dt><link id="MUIClass.Group.TMUIGroup">Group</link> class</dt><dd><link id="MUIClass.Group.TMUIGroup.ActivePage">Group.ActivePage</link> is ex/imported</dd>
  </dl>
</descr>
<seealso>
  <link id="TMUIApplication.Load">Load()</link>
  <link id="MUIClass.Area.TMUIArea.ObjectID">ObjectID</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIApplication.Save.ToEnvarc">
<short>True = save to EnvArc:; False Save to ENV:</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIApplication.ShowHelp">
<short>Show an AmigaGuide help file.</short>
<descr>
The application will be
put to sleep until the file is displayed.
Usually, you don't need to call this method directly.
MUI comes with a sophisticated online help system,
you just need to supply your gadgets with help nodes
and everything will be handled automatically.
</descr>
<seealso>
  <link id="TMUIApplication.HelpFile">HelpFile</link>
  <link id="TMUINotify.HelpNode">HelpNode</link>
  <link id="TMUINotify.HelpLine">HelpLine</link>
</seealso>
</element>

<!-- argument Visibility: default -->
<element name="TMUIApplication.ShowHelp.Window">
<short>Help will be open on tehe same screen as this window, nil for public screen</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIApplication.ShowHelp.HelpFileName">
<short>Filename of the AmigaGuide file, if '' it will use the <link id="TMUIApplication.HelpFile">MUIApp.HelpFile</link></short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIApplication.ShowHelp.Node">
<short>Node to open in the File</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIApplication.ShowHelp.LineNum">
<short>Automatically jump to this line</short>
</element>

<!-- property Visibility: public -->
<element name="TMUIApplication.Broker">
<short>Commodities Broker</short>
<descr>
<p>
If you need to attach some additional commodities objects
to your application (e.g. because you need lots of hotkeys),
you can obtain a pointer to the applications Broker structure
and add some commodities objects.</p>
<p>
MUI will free the complete broker when the application is
disposed, no need for you to free your objects yourself.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TMUIApplication.DiskObject">
<short>Iconify Icon</short>
<descr>
<p>
Pointer to a struct DiskObject, e.g. obtained
from GetDiskObject(). If present, MUI will use
this object for the AppIcon when your application
gets iconified.</p>
<p>
Otherwise MUI use the Icon of the current Program and if
this does not exists it will try to locate "env:sys/dev_mui.info"
or use a generic one.
</p>
</descr>
</element>

<!-- property Visibility: public -->
<element name="TMUIApplication.ForceQuit">
<short>Quit without questions</short>
<descr>
When your input loop receives a Terminate,
you should query this attribute. In case its True, your program
should exit quietly without popping up any safety requesters or
other stuff.
MUI will e.g. set this if the user issued a "QUIT FORCE" ARexx
command to your application.
</descr>
</element>

<!-- property Visibility: public -->
<element name="TMUIApplication.Iconified">
<short>Iconify the Application</short>
<descr>
<p>
Setting this attribute to TRUE causes the application
to become iconified. Every open window will be closed
and a (configurable) AppIcon will appear on the workbench.</p>
<p>
Same thing happens when the user hits the iconify gadget
in the window border or uses commodities Exchange to
hide your applications interface.</p>
<p>
There is no way for you to prevent your application from
being iconified. However, you can react on the iconification
by listening to the OnIconify Event. This allows you to free some resources
you don't need in iconified state.</p>
<p>
When an application is iconified and you try to open a
window, the window won't open immediately. Instead MUI
remembers this action and opens the window once the
application is uniconified again.</p>
</descr>
<seealso>
  <link id="TMUIApplication.DiskObject">DiskObject</link>
</seealso>
</element>

<!-- property Visibility: public -->
<element name="TMUIApplication.Sleep">
<short>Put a whole application to sleep.</short>
<descr>
<p>
  All open windows get disabled and a busy
pointer appears.</p>
<p>
This attribute contains a nesting count, if you tell
your application to sleep twice, you will have to tell
it to wake up twice too.</p>
<p>
If you need to do some time consuming actions, you
always should set this attribute to inform the user
that you are currently unable to handle input.</p>
<p>
A sleeping application's windows cannot be resized.</p>
</descr>
<seealso>
  <link id="MUIClass.Window.TMUIWindow.Sleep">Window.Sleep</link>
  <link id="TMUIApplication.InputBuffered">InputBuffered()</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.Active">
<short>Active Status of the Commodities Setting (in Exchange))</short>
<descr>
This attribute reflects the state that the user adjusted
with commodities Exchange. MUI itself doesn't pay any
attention to it, this is up to you.
</descr>
<seealso>
  <link id="TMUIApplication.Broker">Broker</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.Author">
<short>[i] Name of the applications author.</short>
<descr>
  <p>
  <b>Example</b> </p>
<code>
MUIApp.Title := 'WBMan';
MUIApp.Version := '$VER: WbMan 0.24 (19.7.93)';
MUIApp.Copyright := '© 1993 by Klaus Melchior';
MUIApp.Author := 'Klaus Melchior';
MUIApp.Description := 'Manages the WBStartup.';
MUIApp.Base := 'WBMAN';</code>
</descr>
<seealso>
  <link id="TMUIApplication.Copyright">MUIApp.Copyright</link>
  <link id="TMUIApplication.Version">MUIApp.Version</link>
  <link id="TMUIApplication.Description">MUIApp.Description</link>
  <link id="TMUIApplication.Base">MUIApp.Base</link>
  <link id="TMUIApplication.Title">MUIApp.Title</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.Base">
<short>[i] Basename for an application</short>
<descr>
<p>The basename for an application. This name is used
for the builtin ARexx port and for some internal
file management.</p>
<p>
A basename must neither contain spaces nor any
special characters such as ":/()#?*...".</p>
<p>
When your program is a single task application
(i.e. <link id="TMUIApplication.SingleTask">MUIApp.SingleTaks</link> is True), the
base name will be used without further modification.
</p>
<p>Otherwise, it gets a ".1", ".2", etc. appended,
depending on how many applications are already
running. If you need to know the name of your
ARexx port, you can query the base name attribute
after the application is created.</p>
<p>
  <b>Example</b></p>
<code>
MUIApp.Title := 'WBMan';
MUIApp.Version := '$VER: WbMan 0.24 (19.7.93)';
MUIApp.Copyright := '© 1993 by Klaus Melchior';
MUIApp.Author := 'Klaus Melchior';
MUIApp.Description := 'Manages the WBStartup.';
MUIApp.Base := 'WBMAN';</code>
</descr>
<seealso>
  <link id="TMUIApplication.Copyright">MUIApp.Copyright</link>
  <link id="TMUIApplication.Version">MUIApp.Version</link>
  <link id="TMUIApplication.Description">MUIApp.Description</link>
  <link id="TMUIApplication.Author">MUIApp.Author</link>
  <link id="TMUIApplication.Title">MUIApp.Title</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.BrokerPri">
<short>[i] Adjust the priority of an applications broker.</short>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.Copyright">
<short>[i] A copyright string, containing the year and the company.</short>
<descr>
  <p>
  <b>Example</b> </p>
<code>
MUIApp.Title := 'WBMan';
MUIApp.Version := '$VER: WbMan 0.24 (19.7.93)';
MUIApp.Copyright := '© 1993 by Klaus Melchior';
MUIApp.Author := 'Klaus Melchior';
MUIApp.Description := 'Manages the WBStartup.';
MUIApp.Base := 'WBMAN';</code>
</descr>
<seealso>
  <link id="TMUIApplication.Version">MUIApp.Version</link>
  <link id="TMUIApplication.Description">MUIApp.Description</link>
  <link id="TMUIApplication.Author">MUIApp.Author</link>
  <link id="TMUIApplication.Base">MUIApp.Base</link>
  <link id="TMUIApplication.Title">MUIApp.Title</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.Description">
<short>[i] Short description, about 40 characters. Shown e.g. in commodities exchange.</short>
<descr>
  <p>
  <b>Example</b> </p>
<code>
MUIApp.Title := 'WBMan';
MUIApp.Version := '$VER: WbMan 0.24 (19.7.93)';
MUIApp.Copyright := '© 1993 by Klaus Melchior';
MUIApp.Author := 'Klaus Melchior';
MUIApp.Description := 'Manages the WBStartup.';
MUIApp.Base := 'WBMAN';</code>
</descr>
<seealso>
  <link id="TMUIApplication.Copyright">MUIApp.Copyright</link>
  <link id="TMUIApplication.Version">MUIApp.Version</link>
  <link id="TMUIApplication.Author">MUIApp.Author</link>
  <link id="TMUIApplication.Base">MUIApp.Base</link>
  <link id="TMUIApplication.Title">MUIApp.Title</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.HelpFile">
<short>AmigaGuide style file to be displayed when the user requests online help.</short>
<descr>
<p>When the HELP button is pressed and the application
defines a HelpFile, MUI tries to obtain
<link id="TMUINotify.HelpNode">HelpNode</link> from the current object (the one under
the mouse pointer). If <link id="TMUINotify.HelpNode">HelpNode</link> is not defined,
MUI continues asking the parent object for this
attribute (usually a group, but remember: the parent
of a windows root object is the window itself, the
parent of a window is the application).</p>
<p>
When a set <link id="TMUINotify.HelpNode">HelpNode</link> is found, the same procedure
is applied to <link id="TMUINotify.HelpLine">HelpLine</link>. Then MUI puts the application
to sleep and displays the file at the position specified
with <link id="TMUINotify.HelpNode">HelpNode</link> and/or <link id="TMUINotify.HelpLine">HelpLine</link>.</p>
<p>
This behaviour allows you to define one
HelpFile for your application object
and different help nodes and lines for your applications
windows and/or gadgets.</p>
</descr>
<seealso>
  <link id="TMUINotify.HelpNode">HelpNode</link>
  <link id="TMUINotify.HelpLine">HelpLine</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.Menustrip">
<short>[i] Specify a menu strip object for the application.</short>
<descr>
<p>
The object
is treated as a child of the application and will be disposed
when the application is disposed.</p>
<p>
Menustrip objects defined for the application are used
as menu for every window of the application, as long as
the window doesn't define its private menu.</p>
<p><b>Example:</b></p>
<code>
MUIApp.MenuStrip := TMUIMenuStrip.Create;

Men := TMUIMenu.Create;
with Men do
begin
  Title := 'Test Menu';        // Name of Menu (thats the one in the ScreenBar)
  Parent := MUIApp.MenuStrip;  // attach to the Menustrip
end;

with TMUIMenuItem.Create do
begin
  Title := 'Config';         // Text on the menu item
  Parent := Men;             // attach to the Menu
  OnTrigger := @ConfigStart; // Event to call when selected
end;

with TMUIMenuItem.Create do
begin
  Title := 'Quit';
  Parent := Men;
  OnTrigger := @QuitMe;
end;
</code>
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.SingleTask">
<short>[i] Set application as a single task program</short>
<descr>
<p>
When set to TRUE, MUI will
refuse to create more than one application object.</p>
<p>
In this case, the already running application gets its
<link id="TMUIApplication.OnDoubleStart">OnDoubleStart</link> Event. You
can listen to this and take appropriate actions, e.g.
pop up a requester.</p>
<p>
Examples for single task applications are the system
preferences program. It doesn't make sense for them
to run more than once.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.Title">
<short>[i] Title of an application</short>
<descr>
<p>
The title is e.g. shown in Commodities Exchange
or in the MUI preferences program.</p>
<p>
An application title shall not contain any version
information, just the pure title. Also, special
characters such as ":/()#?*..." are not allowed.</p>
<p>
You should use a quite long and unique name for
your applications. Naming it "Viewer" or "Browser"
is not a wise choice.
</p>
<p>The length of the name must not exceed 30 characters! Strings longer than 30 chars will be cut.</p>
  <p>
  <b>Example</b> </p>
<code>
MUIApp.Title := 'WBMan';
MUIApp.Version := '$VER: WbMan 0.24 (19.7.93)';
MUIApp.Copyright := '© 1993 by Klaus Melchior';
MUIApp.Author := 'Klaus Melchior';
MUIApp.Description := 'Manages the WBStartup.';
MUIApp.Base := 'WBMAN';</code>
</descr>
<seealso>
  <link id="TMUIApplication.Copyright">MUIApp.Copyright</link>
  <link id="TMUIApplication.Version">MUIApp.Version</link>
  <link id="TMUIApplication.Description">MUIApp.Description</link>
  <link id="TMUIApplication.Author">MUIApp.Author</link>
  <link id="TMUIApplication.Base">MUIApp.Base</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.UseCommodities">
<short>[i] Run the application without a commodities interface</short>
<descr> When set to FALSE, the application will run without a
        commodities interface. Think very well before using this
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.Version">
<short>[i] Version string for the application.</short>
<descr>
<p>
This string shall follow standard version string convetions</p>
<p>
<b>Example</b> </p>
<code>
MUIApp.Title := 'WBMan';
MUIApp.Version := '$VER: WbMan 0.24 (19.7.93)';
MUIApp.Copyright := '© 1993 by Klaus Melchior';
MUIApp.Author := 'Klaus Melchior';
MUIApp.Description := 'Manages the WBStartup.';
MUIApp.Base := 'WBMAN';</code>
</descr>
<seealso>
  <link id="TMUIApplication.Copyright">MUIApp.Copyright</link>
  <link id="TMUIApplication.Title">MUIApp.Title</link>
  <link id="TMUIApplication.Description">MUIApp.Description</link>
  <link id="TMUIApplication.Author">MUIApp.Author</link>
  <link id="TMUIApplication.Base">MUIApp.Base</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.OnActivate">
<short>Application got activated by Exchange</short>
<seealso>
  <link id="TMUIApplication.Active">Active</link>
  <link id="TMUIApplication.OnDeactivate">OnDeactivate</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.OnDeactivate">
<short>Application got deactivated by Exchange</short>
<seealso>
  <link id="TMUIApplication.Active">Active</link>
  <link id="TMUIApplication.OnActivate">OnActivate</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.OnDoubleStart">
<short>Second start of a single task application</short>
<descr>
This event is triggered when the user
tries to start a <link id="TMUIApplication.SingleTask">SingleTask</link> application
twice. You can react on this and take appropriate actions,
e.g. pop up a requester or quit yourself.
</descr>
<seealso>
  <link id="TMUIApplication.SingleTask">SingleTask</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.OnIdle">
<short>Event on every message loop cycle</short>
<descr>
  Useful if you want to trigger something on a very short timeframe.
  (for example script execution)
  But be carfull to time consuming routines here can slow down the
  message loop very much resulting in a lagging GUI. Better use a <link id="TMUITimer">Timer</link> in these cases.
</descr>
<seealso>
  <link id="TMUITimer">Timer</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.OnIconify">
<short>Event triggered when the application got iconified</short>
<seealso>
  <link id="TMUIApplication.OnRestore">OnRestore</link>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUIApplication.OnRestore">
<short>Event triggered when application got restored from iconified state</short>
<descr>
</descr>
<seealso>
  <link id="TMUIApplication.OnIconify">OnIconify</link>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TMUIWithParent">
<short>Subclass of TNotify to introduce the Parent relation</short>
<descr>
  Not in <link id="TMUINotify">Notify</link> because <link id="TMUIApplication">Application should not have a Parent</link>
</descr>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIWithParent.SetParent">
<short>Set function for the Parent, maybe overriden by other classes</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIWithParent.SetParent.AParent">
<short>Parent class to set</short>
</element>

<!-- destructor Visibility: public -->
<element name="TMUIWithParent.Destroy">
<short>No need to create directly</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIWithParent.DestroyObject">
<short>No need to create directly</short>
</element>

<!-- property Visibility: public -->
<element name="TMUIWithParent.Parent">
<short>Parent of the Object</short>
<descr>
<p>
  if the parent MUI object gets destroyed, this one also gets destroyed.
  If the parent Object is destroyed this object is also destroyed.
  Unlink the Parent by setting it to nil.
  An Object without Parent you have to destroy yourself at the end of the program.
</p>
<p><b>Example:</b></p>
<code>
constructor TMyWindow.Create;
var
  Grp: TMUIGroup;
begin
  inherited;
  Grp := TMUIGroup.Create; // create a group
  Grp.Horizontal := True;  // make it horizontal
  Grp.Parent := Self;      // put the Group into the Window
  //
  for i := 1 to 3 do      // Create some Buttons
  begin
    with TMUIButton.Create do
    begin
      Contents := 'Button ' + IntToStr(i); // proper names
      Parent := Grp;       // put into the Group, therefore next to each other
    end;
  end;
  //
  with TMUIText.Create do        // Put a text under the Buttons
  begin
    Contents := 'Example Text'; // just some text
    Parent := Self;             // put into the Window (the window is by default a vertical group)
  end;
end;</code>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TMUIFamily">
<short>Base class with list of children</short>
<descr>
<p>
Family class is the base class for objects that are able
to handle a list of children. This is e.g. the case for
MUIs Menustrip, Menu and Menuitem objects.</p>
<p>
Family class defines methods and attributes to
add and remove children, sort children, and transfer
children to other Family objects.</p>
<p>
Group class and application class should also be a
subclass of Family class, but due to BOOPSI system
limitations, this is currently impossible. If the
future will allow more logical class trees, things
might change, but everything will be done in a
compatible manner.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIFamily.GetCreateTags">
<short>Fill Taglist for creating the MUI item</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIFamily.GetCreateTags.ATagList">
<short>TagList to Fill</short>
</element>

<!-- property Visibility: public -->
<element name="TMUIFamily.Childs">
<short>List of Children</short>
<descr>
<p>
When a family is disposed, all of its children will also get deleted.
But you should not directly write Childs here but assign this object to
the Childobject as Parent. It will automatically add it to this list.</p>
<p><b>Example:</b></p>
<code>
// Disable all the Buttons in this Group, and only the Buttons (not recursively)
for i := 0 to Group.Childs.Count - 1 do
begin
  if Group.Childs[i] is TMUIButton then
    TMUIButton(Group.Childs[i]).Disabled := True;
end;
</code>
</descr>
</element>

<!-- class Visibility: default -->
<element name="TMUISemaphore">
<short>Exec Semaphore as MUI Object</short>
<descr>
The semaphore class helps to access dataspace objects
from different tasks. Its methods are identical to the
exec.library semaphore functions and work on the
semaphore thats contained in the Semaphore classes
instance data.
</descr>
</element>

<!-- procedure Visibility: public -->
<element name="TMUISemaphore.CreateObject">
<short>Create Semaphore MUI item</short>
</element>

<!-- function Visibility: public -->
<element name="TMUISemaphore.Attempt">
<short>Emulates exec.library/AttemptSemaphore.</short>
</element>

<!-- function result Visibility: public -->
<element name="TMUISemaphore.Attempt.Result">
<short></short>
</element>

<!-- function Visibility: public -->
<element name="TMUISemaphore.AtteptShared">
<short>Emulates exec.library/AttemptSemaphoreShared.</short>
</element>

<!-- function result Visibility: public -->
<element name="TMUISemaphore.AtteptShared.Result">
<short></short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUISemaphore.Obtain">
<short>Emulates exec.library/ObtainSemaphore.</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUISemaphore.ObtainShared">
<short>Emulates exec.library/ObtainSemaphoreShared.</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUISemaphore.Release">
<short>Emulates exec.library/ReleaseSemaphore.</short>
</element>

<!-- class Visibility: default -->
<element name="TMUIDataspace">
<short>A very simple container for all kinds of data</short>
<descr>
<p>
The Dataspace class serves as a very simple container for
all kinds of data. You can add data items and reference them
later through an ID. Furthermore, Dataspace class features
methods to import/export a complete Dataspace from/to an IFF
file handle.</p>
<p>
MUI uses subclasses of dataspace class to handle all its
configuration data and thats probably the main purpose of a
dataspace.
</p>
<p>This Class is only added for completeness reasons, you might would prefer to use
TList, TObjectList and such classes as usual.</p>
</descr>
<seealso>
</seealso>
</element>

<!-- procedure Visibility: protected -->
<element name="TMUIDataspace.GetCreateTags">
<short>Fill TagList fpr creation of the MUI item</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIDataspace.GetCreateTags.ATagList">
<short>TagList To Fill</short>
</element>

<!-- constructor Visibility: public -->
<element name="TMUIDataspace.Create">
<short>Create a DataSpace object</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIDataspace.CreateObject">
<short>Create the MUI item</short>
</element>

<!-- function Visibility: public -->
<element name="TMUIDataspace.Add">
<short>Adds a new entry to the dataspace.</short>
<descr>
If an entry
with the same ID already exists, it will be replaced with
the new entry.
</descr>
</element>

<!-- function result Visibility: public -->
<element name="TMUIDataspace.Add.Result">
<short>False on Failure (probably because of a memory
shortage) or True on success.</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIDataspace.Add.Data">
<short>Pointer to data</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIDataspace.Add.Len">
<short>Length of Data</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIDataspace.Add.Id">
<short>reference ID</short>
</element>

<!-- procedure Visibility: public -->
<element name="TMUIDataspace.Clear">
<short>Clear all the contents of a dataspace</short>
<descr>
Depending
on the state of the memory pool that the dataspace object uses,
this may or may not result in more free memory.
</descr>
</element>

<!-- function Visibility: public -->
<element name="TMUIDataspace.Find">
<short>Find data by it's reference ID'</short>
<descr>
</descr>
<seealso>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TMUIDataspace.Find.Result">
<short>Pointer to the Data or nil if not found</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIDataspace.Find.Id">
<short>Reference ID of the data to get</short>
</element>

<!-- function Visibility: public -->
<element name="TMUIDataspace.Merge">
<short>Add two Dataspace objects contents together</short>
<descr>
This method adds all the contents of the merge dataspace
specified as parameter to the objects dataspace.
As with <link id="TMUIDataspace.Add">Add</link>M, entries with equal IDs
will be replaced.
</descr>
<seealso>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TMUIDataspace.Merge.Result">
<short>Returns the number of entries that have been
added/replaced in the objects dataspace. If this
number doesnt match the number of entries in the
merge dataspace, something probably went wrong.</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIDataspace.Merge.DS">
<short>dataspace objects whichs contents should be merged.</short>
</element>

<!-- function Visibility: public -->
<element name="TMUIDataspace.ReadIFF">
<short>Adds the contents of an IFF handle from iffparse.library to the dataspace.</short>
<descr>
<p>
As always, objects with the same ID that
are already in the dataspace will be replaced.</p>
<p>
This method does not look for any chunk types and chunk ids
itself. Instead, it expects that you have already located
the chunk which contains your data and does nothing
but ReadChunkBytes() until all dataspace entries of
the current chunk are read.</p>
<p>
Do not call ReadIFF if your handle is
positioned on chunks that were not written with
<link id="TMUIDataspace.WriteIFF">WriteIFF</link>
or strange things may happen!
</p>
</descr>
<seealso>
  <link id="TMUIDataspace.WriteIFF">WriteIFF</link>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TMUIDataspace.ReadIFF.Result">
<short>Returns 0 on success or some IFFERR_xxx on failure.</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIDataspace.ReadIFF.IFFHandle">
<short>
pointer to a struct IFFHandle from
iffparse.library/AllocIFF(). The handle must
already be open, initialized for reading and
positioned on a chunk that was created with
<link id="TMUIDataspace.WriteIFF">WriteIFF</link>.</short>
</element>

<!-- function Visibility: public -->
<element name="TMUIDataspace.WriteIFF">
<short>Writes the contents of a dataspace to an IFF handle of iffparse.library.</short>
<descr>
In detail, a chunk with the specified type and id is created
with PushChunk(), the contents of the dataspace are written
with WriteChunkBytes() and the chunk is terminated with
PopChunk().
</descr>
<seealso>
  <link id="TMUIDataspace.ReadIFF">ReadIFF</link>
</seealso>
</element>

<!-- function result Visibility: public -->
<element name="TMUIDataspace.WriteIFF.Result">
<short>Returns 0 on success or some IFFERR_xxx on failure.</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIDataspace.WriteIFF.IFFHandle">
<short>pointer to a struct IFFHandle from
iffparse.library/AllocIFF(). The handle must
already be open and initialized for writing.</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIDataspace.WriteIFF.typ">
<short>type of chunk to create</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIDataspace.WriteIFF.ID">
<short>ID of chunk to create</short>
</element>

<!-- function Visibility: public -->
<element name="TMUIDataspace.Remove">
<short>Removes an entry from the dataspace.</short>
</element>

<!-- function result Visibility: public -->
<element name="TMUIDataspace.Remove.Result">
<short>True if found and removed.</short>
</element>

<!-- argument Visibility: default -->
<element name="TMUIDataspace.Remove.Id">
<short>Reference ID to remove</short>
</element>

<!-- property Visibility: public -->
<element name="TMUIDataspace.Pool">
<short>[i] Specify your own Memory Pool</short>
<descr>
If you specify a memory pool from exec.library/CreatePool()
here, the dataspace object will use this pool for all its
entries.
If leave this field to nil, the dataspace object
will create its own memory pool instead.
</descr>
<seealso>
</seealso>
</element>

<!-- class Visibility: default -->
<element name="TMUITimer">
<short>A simple Timer object</short>
<descr>
<p>
  Timers are automatically connected to the MUIApp, therefore you don't need to destroy them.
  They will be destroyed automatically on program end by the Application object.</p>
<p><b>Example:</b></p>
<code>
// Timer event
procedure TMyWindow.TimerEvent(Sender: TObject);
begin
  writeln('Timer triggered');
end;

// Create a new Timer if needed
procedure TMyWindow.ButtonClick(Sender: TObject);
begin
  if not Assigned(Timer) then
  begin
    Timer := TMUITimer.Create;
    Timer.Interval := 1000; // in ms -> 1 second
    Timer.OnTimer := @TimerEvent; // connect the event
  end;
  Timer.Enabled := not Timer.Enabled; // Toggle timer on Button Click
end;
</code>
</descr>
</element>

<!-- constructor Visibility: public -->
<element name="TMUITimer.Create">
<short>Create a new Timer object</short>
</element>

<!-- destructor Visibility: public -->
<element name="TMUITimer.Destroy">
<short>Destroy this Timer Object</short>
<descr>
  Usually this is not needed, the Timer will be automatically destroyed with the application.
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUITimer.Enabled">
<short>Enable/Disable the Timer</short>
<descr>
  Do not forget to connect the <link id="TMUITimer.OnTimer">OnTimer</link> event and the <link id="TMUITimer.Interval">Interval</link>. The Timer can only run,
  when the Messageloop is running.
</descr>
<seealso>
</seealso>
</element>

<!-- property Visibility: published -->
<element name="TMUITimer.Interval">
<short>Interval the Timer should trigger the <link id="TMUITimer.OnTimer">OnTimer</link> event in Milliseconds</short>
<descr>
  Please remember this time is a minimal millisecond time, when the time is due
  the message loop will call the event handler, therefore it can be a little be delayed.
</descr>
</element>

<!-- property Visibility: published -->
<element name="TMUITimer.OnTimer">
<short>Event to be called when the <link id="TMUITimer.Interval">Interval</link> is due</short>
</element>

<!-- argument Visibility: default -->
<element name="ComplainIOnly.AClass">
<short>Class where the field was called (the classname will be printed)</short>
</element>

<!-- argument Visibility: default -->
<element name="ComplainIOnly.Field">
<short>Name of the init-only field tried to change on runtime</short>
</element>

<!-- argument Visibility: default -->
<element name="ComplainIOnly.Value">
<short>Value the init-only field should be set (and will be ignored)</short>
</element>

<!-- variable Visibility: default -->
<element name="MUIApp">
<short>The global MUI Application object</short>
<descr>
  <p>
  This Application object is created at start of the program and destroyed on it's end.
  Create some <link id="MUIClass.Window.TMUIWindow">Windows</link> they will be automatically connected to the application</p>
  <code>Window := TMUIWindow.Create;</code>
  <p>and start the application with</p>
  <code>MUIApp.Run;</code>
  <p>You can terminate the application by closing the main window
  e.g. <link id="MUIClass.Window.TMUIWindow">TMUIWindow</link>(MUIApp.<link id="TMUIApplication.MainWindow">MainWindow</link>).<link id="MUIClass.Window.TMUIWindow.Close">Close()</link>
  or by calling <link id="TMUIApplication.Terminate">MUIApp.Terminate()</link></p>
<p>
<b>Example:</b></p>
<code>
program HelloWorld;
uses
  MUIClass.Window, MUIClass.Area, MUIClass.Base;
begin
  with TMUIText.Create do
  begin
    Contents := 'Hello World';
    Parent := TMUIWindow.Create;
  end;
  MUIApp.Run;
end.
</code>


</descr>
<seealso>
  <link id="TMUIApplication.Run">MUIApp.Run</link>
</seealso>
</element>

</module> <!-- MUIClass.Base -->

</package>
</fpdoc-descriptions>
